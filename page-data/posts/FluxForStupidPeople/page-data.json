{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/FluxForStupidPeople","result":{"data":{"markdownRemark":{"id":"185ca56c-e0f8-50ac-a1a3-f2b6c8890148","html":"<blockquote>\n<p>原文地址：<a href=\"http://blog.andrewray.me/flux-for-stupid-people/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://blog.andrewray.me/flux-for-stupid-people/</a></p>\n</blockquote>\n<p>篇幅过长，没有阅读（<a href=\"http://zhidao.baidu.com/link?url=J-CJXq3dC4oPgQacI5pukD_S4-9HagnMMGB4YJT9hUFufaHxH7enybUz7e6vBEpW4IyV8wOZqNLvl_CMEYs6Jq\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TL;DR</a>）。作为一个脑袋不咋灵光的人，在我挣扎着学习Flux时，希望有人能告诉我这篇文章里的内容。这不是一篇简单的、好的文档，而且它还有许多需要改正的部分内容。</p>\n<p>这篇文章，紧接着上篇《给新手（笨笨）准备的ReactJS介绍》</p>\n<!-- more -->\n<p>我该用Flux么？</p>\n<p>如果你的应用要处理一些<strong>动态数据</strong>的话，那么答案是“<strong>是的</strong>”，你很可能应该用Flux。</p>\n<p>如果你的应用只是不用共享状态的<strong>静态页面</strong>，且你永远不需要保存或者更新数据，那么答案是“<strong>不</strong>”，Flux不会给你带来任何提升。</p>\n<p>为什么用Flux？</p>\n<p>小幽默下，因为Flux本是个难以理解的概念，为什么你还把问题整的更加复杂？</p>\n<p>90%的iOS应用通过<strong>table view呈现数据</strong>。iOS工具包把数据呈现与数据模型定义的非常好，以至于让开发过程变得很简单。</p>\n<p>在前端，我们没有如iOS那样的便利条件，相反的<strong>我们有个大麻烦</strong>，那就是没人知道怎么正确的构建一个前端应用程序。说真的，我在这个行业工作了几年了，从没有一个“最佳实践”讲授这方面内容的。相对应的“库”倒是很多，jQuery？Angular？Backbone？Handlebars？这些库都避开了数据流（data flow）的处理，数据流该怎么处理始终困扰着我们。</p>\n<p>Flux是啥？</p>\n<p>Flux是一个描述了对指定的事件和监听器进行“单向”数据流处理的一个概念词。所以根本没有名叫Flux的这么个库，但你需要的是<a href=\"https://github.com/facebook/flux/blob/master/src/Dispatcher.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Flux分配器</a>（Flux Dispatcher）和任何一个Javascript<a href=\"http://notes.jetienne.com/2011/03/22/microeventjs.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">事件库</a>。</p>\n<p><a href=\"http://notes.jetienne.com/2011/03/22/microeventjs.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">官方文档</a>被写得很意识流（stream of conciousness），而且它并不适合开始学习Flux。一旦你理解了Flux，再去看文档会感觉融会贯通。</p>\n<p>不要尝试去比较Flux和MVC架构，那会让你更加困惑。</p>\n<p>好了，让我们开始吧，为了<strong>解释Flux的概念</strong>我会用例子带你了解它们。</p>\n<h2 id=\"1-视图分派了一个操作\" style=\"position:relative;\"><a href=\"#1-%E8%A7%86%E5%9B%BE%E5%88%86%E6%B4%BE%E4%BA%86%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C\" aria-label=\"1 视图分派了一个操作 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 视图“分派了”“一个操作”</h2>\n<p>一个<strong>分配器（dispatcher）</strong>是基于一个事件系统使用的。它被用来广播触发的事件并注册事件的回调，而且有且<strong>只有一个全局分配器</strong>。你应该使用Facebook <a href=\"https://github.com/facebook/flux/blob/master/src/Dispatcher.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Dispatcher Library</a>。它非常容易初始化：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> AppDispatcher <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Dispatcher</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </code></pre></div>\n<p>让我们做个“new”按钮，用来像列表中添加个事项。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>createNewItem <span class=\"token punctuation\">}</span><span class=\"token operator\">></span>New Item<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>  </code></pre></div>\n<p>在按钮被点击时发生了什么？你的视图<strong>派发了一个特定的事件</strong>，事件中包含着事件名和新事项的数据，如下代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">createNewItem</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">evt</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  AppDispatcher<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    eventName<span class=\"token operator\">:</span> <span class=\"token string\">'new-item'</span><span class=\"token punctuation\">,</span>\n    newItem<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Marco'</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// example data</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"2-存储响应了分配器事件\" style=\"position:relative;\"><a href=\"#2-%E5%AD%98%E5%82%A8%E5%93%8D%E5%BA%94%E4%BA%86%E5%88%86%E9%85%8D%E5%99%A8%E4%BA%8B%E4%BB%B6\" aria-label=\"2 存储响应了分配器事件 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. “存储”响应了分配器事件</h2>\n<p>跟Flux一样，“Store”（存储）也是Facebook发明的一个词。在我们的应用程序中，我们需要为列表指定一个集合来存放逻辑和数据。这就是我们的“Store”，我们暂且称之为ListStore。</p>\n<p>一个store作为一个单例模型，这意味着你不应该使用<code class=\"language-text\">new</code>来声明它。ListStore是一个全局的对象，如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 全局的对象描述了数据和逻辑</span>\n<span class=\"token keyword\">var</span> ListStore <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">// 模型数据的真实数据集合</span>\n  items<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// 附加的方法，我们稍后会用到</span>\n  <span class=\"token function-variable function\">getAll</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>你的store接下来响应了被分配的事件</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> ListStore <span class=\"token operator\">=</span> …\n\nAppDispatcher<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">payload</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span> payload<span class=\"token punctuation\">.</span>eventName <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'new-item'</span><span class=\"token operator\">:</span>\n\n      <span class=\"token comment\">// 我们得到了变更后（mutate）的数据!</span>\n      ListStore<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span> payload<span class=\"token punctuation\">.</span>newItem <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 为了实现Flux的Promise必须加的</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这就是Flux如何派发回调函数的传统方式。每个payload包含了一个事件名和数据。一个switch分支条件决定具体用什么操作。</p>\n<p>🔑 关键概念：<strong>Store并不是模型（model），一个store包含一个或多个模型（models）</strong></p>\n<p>🔑 关键概念：应用中的每个store只专注于如何更新数据。<strong>这是Flux中最关键的部分。</strong>我们派发的事件并不知道如何添加或删除数据元素。</p>\n<p>如果，举个例子，你程序中另一部分需要保存一些图片和它们的元数据，你应再新建个store，起名为ImageStore。在程序中，每个store<strong>代表一个单独的“领土”（domain）</strong>。如果你的程序比较大，领土（domain）需要命名的很容易识别，如果你的程序较小，很可能你只需要1个store。</p>\n<p><strong>只有你的store们</strong>被允许注册到分配器的回调上。你的视图不应该调用<code class=\"language-text\">AppDispatcher.register</code>。分配器只用来从视图向store们发送消息。视图将响应不同于事件的类型。</p>\n<h2 id=\"3-store触发了一个change事件\" style=\"position:relative;\"><a href=\"#3-store%E8%A7%A6%E5%8F%91%E4%BA%86%E4%B8%80%E4%B8%AAchange%E4%BA%8B%E4%BB%B6\" aria-label=\"3 store触发了一个change事件 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Store触发了一个change事件</h2>\n<p>我们快接近核心了！现在数据确实改变了，我们要通知全世界。</p>\n<p>你的store触发一个事件，但<strong>不使用分配器</strong>。这有点令人困惑，但这就是Flux的特殊方式。让我们给我们的store一个触发事件的能力。如果你正在用<a href=\"http://notes.jetienne.com/2011/03/22/microeventjs.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MicroEvent.js</a>，那么是非常简单的：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//MicroEvent.mixin( ListStore );  </span>\n\n<span class=\"token comment\">//Then let's trigger our change event:</span>\n\n<span class=\"token comment\">// 让我们触发change事件：</span>\n\n<span class=\"token keyword\">case</span> <span class=\"token string\">'new-item'</span><span class=\"token operator\">:</span>\n\n  ListStore<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span> payload<span class=\"token punctuation\">.</span>newItem <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 向世界大声喊着“我们改变了！”</span>\n  ListStore<span class=\"token punctuation\">.</span><span class=\"token function\">trigger</span><span class=\"token punctuation\">(</span> <span class=\"token string\">'change'</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>🔑 关键概念：在<code class=\"language-text\">触发</code>change事件时，不用传最新的item值，视图只关心<em>什么东西</em>发生了改变。让我们继续跟踪数据，去理解到底是为什么。</p>\n<h2 id=\"4-event视图响应了change事件\" style=\"position:relative;\"><a href=\"#4-event%E8%A7%86%E5%9B%BE%E5%93%8D%E5%BA%94%E4%BA%86change%E4%BA%8B%E4%BB%B6\" aria-label=\"4 event视图响应了change事件 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Event视图响应了change事件</h2>\n<p>现在我们需要显示列表。列表内容改变时，我们的视图要<strong>完全的重新渲染</strong>。那不是个错误。</p>\n<p>首先，我们让组件首次被创建时监听从ListStore发来的<code class=\"language-text\">change</code>事件：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">componentDidMount</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n  <span class=\"token function\">ListStore</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span> <span class=\"token string\">'change'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>listChanged <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></code></pre></div>\n<p>For simplicity’s sake, we’ll just call <code class=\"language-text\">forceUpdate</code>, which triggers a re-render. A different approach would be to store the entire list in <code class=\"language-text\">state</code>.</p>\n<p>为了简单起见，我们只调用<code class=\"language-text\">forceUpdate</code>方法，它触发了一个重绘操作，这是个不同的处理方法，把整个列表存储到<code class=\"language-text\">状态(state)</code>中。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">listChanged</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n  <span class=\"token comment\">// Since the list changed, trigger a new render.</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">forceUpdate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></code></pre></div>\n<p>Don’t forget to clean up your event listeners when your component “unmounts,” which is when it goes back to hell:</p>\n<p>在你的组件卸载时（unmounts），不要忘记清理事件监听：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">componentWillUnmount</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n  ListStore<span class=\"token punctuation\">.</span><span class=\"token function\">unbind</span><span class=\"token punctuation\">(</span> <span class=\"token string\">'change'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>listChanged <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></code></pre></div>\n<p>Now what? Let’s look at our render function, which I’ve purposely saved for last.</p>\n<p>现在呢？让我们看下我们的渲染函数，这是整个函数的全貌：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">render</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">// 切记，ListStore是全局的</span>\n  <span class=\"token keyword\">var</span> items <span class=\"token operator\">=</span> ListStore<span class=\"token punctuation\">.</span><span class=\"token function\">getAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 在整个列表上使用循环创建列表项</span>\n  <span class=\"token keyword\">var</span> itemHtml <span class=\"token operator\">=</span> items<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">item</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// \"key\"很重要，应该是唯一的，用来标记每个列表项</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>li key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span> listItem<span class=\"token punctuation\">.</span>id <span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n      <span class=\"token punctuation\">{</span> listItem<span class=\"token punctuation\">.</span>name <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">></span>\n        <span class=\"token punctuation\">{</span> itemHtml <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ul<span class=\"token operator\">></span>\n\n    <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>createNewItem <span class=\"token punctuation\">}</span><span class=\"token operator\">></span>New Item<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>我们回顾下整个流程。</strong>当你为列表新添加一项时，<em>view分派一个动作(action)</em>，store响应这个动作(action)，store随之更新，同时<em>触发</em>一个change事件，view响应这个change事件进行重绘。</p>\n<p>但还有个问题，当列表改变时我们<strong>重绘整个view</strong>，这是不是效率太低了？！</p>\n<p>当然不是。</p>\n<p>诚然，我们再一次的调用重绘方法，自然的所有渲染方法的代码都要重新运行。但<strong>React将只重绘你修改了的真正DOM</strong>。<code class=\"language-text\">render</code>函数实际上生成了一个”virtual DOM”，React会对比上一次<code class=\"language-text\">render</code>的输出，如果两个virtual DOM不同，React只会更新他们之间的不同DOM点而不是整个DOM。</p>\n<p>🔑 关键概念：当store数据改变时， <strong>view不应该关心数据是被新添、删除或者是被修改。</strong> 它们（数据）应完全的重绘。React的“virtual DOM”的diff算法承担了“搞清楚真正的DOM节点变化”的重任。这样让开发者更轻松（原句：让你的生活更简单，避免你的血压升高）。</p>\n<h2 id=\"还有一件事：action-creator是个啥玩意？\" style=\"position:relative;\"><a href=\"#%E8%BF%98%E6%9C%89%E4%B8%80%E4%BB%B6%E4%BA%8B%EF%BC%9Aaction-creator%E6%98%AF%E4%B8%AA%E5%95%A5%E7%8E%A9%E6%84%8F%EF%BC%9F\" aria-label=\"还有一件事：action creator是个啥玩意？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>还有一件事：Action Creator是个啥玩意？</h2>\n<p>记住，当我们点击按钮，我们分派了一个特定的事件：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">AppDispatcher<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>  \n  eventName<span class=\"token operator\">:</span> <span class=\"token string\">'new-item'</span><span class=\"token punctuation\">,</span>\n  newItem<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Samantha'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如果你的许多视图都要需要触发这个事件，那么要重复书写非常多的代码。再加上，你所有的视图需要知道特定的对象格式，这样是很别扭的。所以Flux建议一个抽象，叫做 <strong>action creators（操作生成器）</strong>，它只是把上面的代码抽象为一个方法。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  ListActions <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">add</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">item</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      AppDispatcher<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        eventName<span class=\"token operator\">:</span> <span class=\"token string\">'new-item'</span><span class=\"token punctuation\">,</span>\n        newItem<span class=\"token operator\">:</span> item\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>现在视图只要简单的调用<code class=\"language-text\">ListActions.add({ name: &#39;...&#39; });</code>并且不用担心被分配的对象语法了。</p>\n<h2 id=\"未回答的问题\" style=\"position:relative;\"><a href=\"#%E6%9C%AA%E5%9B%9E%E7%AD%94%E7%9A%84%E9%97%AE%E9%A2%98\" aria-label=\"未回答的问题 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>未回答的问题</h2>\n<p>Flux只告诉我们了如何去管理数据流，它并<strong>没有回答</strong>下面这些问题：</p>\n<ul>\n<li>如何从服务器上读取和保存数据？</li>\n<li>我应该如何处理组件和非组件之间的通信？</li>\n<li>我应该用什么样的事件库呢？</li>\n<li>为什么Facebook还没有通过库的方式发布Flux？</li>\n<li>我是否应该在store中启用一个数据层（像Backbone）？</li>\n</ul>\n<p>这些问题的统一的答案是：<strong>随你便！</strong></p>\n<h2 id=\"就是这些了\" style=\"position:relative;\"><a href=\"#%E5%B0%B1%E6%98%AF%E8%BF%99%E4%BA%9B%E4%BA%86\" aria-label=\"就是这些了 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>就是这些了</h2>\n<p>访问Facebook提供的<a href=\"https://github.com/facebook/flux/tree/master/examples/flux-todomvc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Example Flux Application</a>作为附加学习资源。希望在读完本文后，<code class=\"language-text\">js/</code>目录下的文件会变得更容易理解吧。</p>\n<p><a href=\"http://facebook.github.io/flux/docs/overview.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Flux文档</a>里面包含了一些非常有用的知识（原文：金块nuggets），这些知识点被埋在了撰写不易文档深处。</p>\n<p>这篇文章帮助你理解Flux，加我的推吧。</p>","fields":{"slug":"/posts/FluxForStupidPeople","tagSlugs":["/tag/react/","/tag/flux/","/tag/翻译/"]},"frontmatter":{"date":"2015-01-14","description":"作为一个脑袋不咋灵光的人，在我挣扎着学习Flux时，希望有人能告诉我这篇文章里的内容。这不是一篇简单的、好的文档，而且它还有许多需要改正的部分内容。这篇文章，紧接着上篇《给新手（笨笨）准备的ReactJS介绍》","tags":["React","Flux","翻译"],"title":"给新手（笨笨）准备的Flux介绍","socialImage":null}}},"pageContext":{"slug":"/posts/FluxForStupidPeople"}}}